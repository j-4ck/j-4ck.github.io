---
title: 'Blog post 1: What the hell npm!?'
date: 2025-09-10
permalink: /posts/2025/09/blog-post-1/
tags:
  - Javascript
  - NPM
  - Social Engineering
  - Crypto
---


Over September 8th-9th, a complex supply chain attack took place across 18 widely used npm packages amongst others amassing a total of 2 billion weekly downloads... Already my thoughts are why aren't dependencies with tens of millions of downloads a day not included in the standard library or built ins etc and maintained partially by the official dev team!? Whatever..

“Yep, I’ve been pwned. 2FA reset email, looked very legitimate,”
-------

![Phishing email](/images/npm2faPhishing.png)

A clever phishing email pointing to npmjs.help managed to inject malicious [crypto clipping](https://medium.com/@Ekenejoseph/what-is-bitcoin-clipper-and-its-effect-618e93ae7a2c) malware into seemingly regular packages

"Qix" or Josh Junon was quickly found to be pushing snippets of super obfuscated code to many of the repositories he was trusted to maintain. He even says it himself: "have had a stressful week" - See everybody wants to believe that they will never fall for phishing emails just because they have been going on since the dawn of time. The reality is that this is not the case. Phishing scams and emails are getting more complex and intelligent as time goes on and you should never underestimate encountering social engineering techniques when you are tired or off guard.
Later the attackers targeted another maintainer with the same attack vector. 
"Hi, yep I got pwned. Sorry everyone, very embarassing" (Hacker News)

What does the malicious code do then?
-------

According to a comprehensive post by [Aikido.deb](https://www.aikido.dev/blog/npm-debug-and-chalk-packages-compromised) that I reccomend reading for a more in-depth analysis, the main functionality of the malicious code is to hook JavaScript functions and crypto wallet APIs such as window.ethereum and others. Then, it silently waits until a transaction arrives to hook, before using the [Levenshtein distance algorithm](https://en.wikipedia.org/wiki/Levenshtein_distance) in order to match the destination address to a similar one of seemingly hundreds of encoded wallet addresses in the obfuscated code.

How could this have been prevented?
-------

Only idiots will suggest "ahh these maintainers should be more careful!!!" because really these are intelligent attacks that everybody is susceptible to.. My main gripe is why do so many JavaScript programs and even dependencies depend on so many other things?? Every time you use someone else's code in your code, you are trusting them to a degree with your codebase and your security. The external code your program relies on, also relies on other dependencies, which rely on different dependencies, and you end up with this messy web of codebases and trust issues, nicknamed fittingly as ["Dependency hell"](https://en.wikipedia.org/wiki/Dependency_hell).
Am I saying not to use well maintained dependencies for complex operations? No. But are dependencies like "is-even" necessary for example?? Is it worth the trust that you lose when trading 30 seconds of your time for a greater threat risk?

The best bet for programmers at home is to continue to use only well maintained trusted packages when necessary - luckily other package maintainers quickly caught on to something fishy which is why the malware was exposed so quickly.
